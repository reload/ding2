<?php

/**
 * @file
 * Module for interlibrary loans.
 */

use OpenSearch\OpenSearchTingObject;
use OpenSearch\OpenSearchTingObjectCollection;
use Ting\TingObjectInterface;

/**
 * Implements hook_init().
 */
function ding_ill_init() {
  // As we can't know when a new reservation is created by the React button,
  // we'll clear the cache whenever the user visits the reservation pages.
  if (strpos(current_path(), 'user/') === 0 && strpos(current_path(), 'reservations') !== FALSE) {
    ding_session_cache_clear('fbs', 'reservation');
  }
}

/**
 * Implements hook_preprocess_html().
 */
function ding_ill_preprocess_html(&$variables) {
  // If the material is unavailable, add a class to the body.
  if (isset($GLOBALS['ding_ill_material_available']) && $GLOBALS['ding_ill_material_available'] === FALSE) {
    $variables['classes_array'][] = 'no-holdings';
  }

  // Need Drupal.settings.ding_ill to trigger label change in
  // ding_availability_labels.js, but we don't really need any settings.
  drupal_add_js(['ding_ill' => ['active' => TRUE]], 'setting');
}

/**
 * Implements hook_menu().
 */
function ding_ill_menu() {
  $items['ding_ill/openholdingstatus/%'] = [
    'title' => 'OpenHoldingStatus',
    'page callback' => 'ding_ill_openholdingstatus',
    'page arguments' => [2],
    // Allow anyone to access.
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  ];

  $items['admin/config/ding/ill'] = array(
    'title' => 'Ding ILL button',
    'description' => 'Configure the inter-library loan button.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ding_ill_settings'),
    'access arguments' => array('administer ding provider'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function ding_ill_menu_alter(&$items) {
  // Replace a page callback with our own. This way we do not have to check on
  // every request as if we used hook_init().
  $items['ting/object/%ting_object'] = array_merge(
    $items['ting/object/%ting_object'],
    [
      'page callback' => 'ding_ill_ting_object_page_view',
      // Pass the original page callback as an argument. This allows the
      // overrider to call the original.
      'page arguments' => [2, $items['ting/object/%ting_object']['page callback']],
    ]
  );
}

/**
 * Custom ting object view page callback
 *
 * @param \TingEntity $object
 *   The object being viewed.
 * @param string $original_callback
 *   The name of the original callback.
 */
function ding_ill_ting_object_page_view($object, $original_callback) {
  // Redirect local items without holdings to a basis item if available.
  $is_local_object = variable_get('ting_agency', -1) === $object->getOwnerId();
  if ($is_local_object) {
    $local_id = $object->getLocalId();
    $holdings = ding_availability_holdings([$local_id]);
    $has_holdings = $holdings[$local_id]['total_count'] > 0;
    if (!$has_holdings) {
      $basis_id = "870970-basis:" . $object->getLocalId();
      $basis_object = opensearch_get_object($basis_id);
      if ($basis_object) {
        drupal_goto('ting/object/' . $basis_object->id);
      }
    }
  }

  return call_user_func($original_callback, $object);
}

/**
 * Implements hook_ting_collection_view_alter().
 */
function ding_ill_ting_collection_view_alter(&$build) {
  global $language;

  // Replace all local objects without holdings with a corresponding basis
  // object shared between libraries.
  // This should only occur on the collection view so pass for other paths.
  if (strpos(current_path(), 'ting/collection') !== 0) {
    return;
  }

  /* @var \TingCollection $collection */
  $collection = $build['#object'];
  $objects = $collection->getTingObjectCollection()->getObjects();


  $local_objects = array_filter(
    $objects,
    function(TingObjectInterface $object) {
      return variable_get('ting_agency', -1) === $object->getOwnerId();
    }
  );

  // Identify local objects which do not have any holdings. Only if any of these
  // are present do we want to consider doing any actual replacement as that
  // introduces complexity, potential errors and performance penalties due to
  // extra external webservice requests.
  $local_objects_without_holdings = array_filter(
    $local_objects,
    function(TingObjectInterface $object) {
      $local_id = $object->getSourceId();
      $holdings = ding_availability_holdings([$local_id]);
      return $holdings[$local_id]['total_count'] == 0;
    }
  );
  if (count($local_objects_without_holdings) == 0) {
    return;
  }

  // Identify local objects which have a corresponding basis object.
  // To work with all the objects we need all of them as TingClientObject
  // instances. That conversion also happens here.
  $new_objects = array_map(function(OpenSearchTingObject $object) {
    $basis_object = FALSE;
    if (variable_get('ting_agency', -1) === $object->getOwnerId()) {
      // Basis objects are always prefixed with 870970-basis: followed by the
      // faust nummer. In our case this is the source id.
      $basis_id = "870970-basis:" . $object->getSourceId();
      $basis_object = opensearch_get_object($basis_id);
    }
    // Return the basis object or a TingClientObject instance of the local
    // object.
    return $basis_object ?: opensearch_get_object($object->getId());
  }, $objects);

  // Check if we actually did any replacement. If not then bail to avoid further
  // modifications.
  $objects_modified = array_map(function(OpenSearchTingObject $a, TingClientObject $b) {
    return $a->getId() !== $b->id;
  }, $objects, $new_objects);
  if (count(array_filter($objects_modified)) === 0) {
    return;
  }

  // Build a new collection based on the new objects. As many as possible should
  // either be local objects with holdings or basis objects.
  $new_collection = new TingCollection(
    $collection->getId(),
    new OpenSearchTingObjectCollection(
      new TingClientObjectCollection(
        $new_objects
      )
    )
  );

  $build['#object'] = $new_collection;

  // Rerender the collection field with the new collection and merge the result
  // into the build array.
  // Some entries collide when the old and new field are merged unset them to
  // keep the proper values.
  $field = field_attach_view('ting_collection', $new_collection, $build['#view_mode'], $language->language);
  unset($field['ting_entities']['#items']);
  unset($build['ting_entities'][0]);
  $build = drupal_array_merge_deep(
    $build,
    $field
  );
}

/**
 * Settings form.
 */
function ding_ill_settings() {
  $form['ding_ill_auth_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Name'),
    '#default_value' => variable_get('ding_ill_auth_name', ''),
  );

  $form['ding_ill_auth_pass'] = array(
    '#type' => 'textfield',
    '#title' => t('Password'),
    '#default_value' => variable_get('ding_ill_auth_pass', ''),
  );

  $form['ding_ill_auth_group'] = array(
    '#type' => 'textfield',
    '#title' => t('Group'),
    '#default_value' => variable_get('ding_ill_auth_group', ''),
  );

  return system_settings_form($form);
}

/**
 * Implements hook_ding_entity_buttons().
 */
function ding_ill_ding_entity_buttons($type, $entity) {
  global $user;

  /** @var \TingEntity $entity */
  $build = array();

  if ($type !== 'ding_entity') {
    return;
  }

  $ting_object = $entity->getTingObject();

  // Do not add a button for articles. The digital archive service (das)
  // provides a more convenient way to retrieve such items.
  $types = [
    'Artikel',
    'Avisartikel',
    'Tidsskriftsartikel',
  ];
  if (in_array($ting_object->getType(), $types)) {
    return $build;
  }

  if (_ding_ill_is_local($entity)) {
    return $build;
  }
  else {
    // Add global variable to add body class when material is unavailable.
    $GLOBALS['ding_ill_material_available'] = FALSE;
  }

  // These types should just link to bibliotek.dk.
  $types = [
    'Avis',
    'Periodikum',
    'Tidsskrift',
    'Ã…rbog',
  ];
  if (in_array($ting_object->getType(), $types)) {
    $options = array(
      'attributes' => array(
        'class' => 'action-button button-order use-ajax',
      ),
    );

    $build[] = [
      '#type' => 'markup',
      '#markup' => l(
        t('Order at bibliotek.dk'),
        'https://bibliotek.dk/linkme.php?rec.id=' . $ting_object->getId(),
        $options
      ),
    ];

    return $build;
  }

  $ids = [$entity->ding_entity_id];
  // On collection view, ding_ill_preprocess_field has added a property with all
  // the ids of entities to try and order.
  if (isset($entity->ding_ill_ids)) {
    $ids = $entity->ding_ill_ids;
  }

  // Determine options for the order based on user reservation
  // preferences.
  $preferred_branch = NULL;
  try {
    $default_options = ding_provider_invoke('reservation', 'default_options',
    $user);
    $interest_period = $default_options["interest_period"];
    $expiry = (new DateTime())
      ->setTimestamp(REQUEST_TIME)
      ->modify("+{$interest_period}days");
    // Different providers have different option names for the
    // preferred branch. Try to find the right one.
    $preferred_branch_options = array_filter($default_options,
    function ($option_name) {
      return strpos($option_name, 'preferred_branch') !== FALSE;
    }, ARRAY_FILTER_USE_KEY);
    $preferred_branch = array_shift($preferred_branch_options);
  }
  catch (DingProviderAuthException $e) {
    // Do nothing. The React component should also pick up on the fact
    // that the user is not logged in and redirect to the login url.
    // Set expiry to now to have a object to work with.
    $expiry = new DateTime();
  }

  $data = [
    'text' => t('Reserve'),
    'help-text' => t('The material is ordered from another library'),
    'error-text' => t('An error occurred'),
    'checking-text' => t('Checking if material can be ordered'),
    'progress-text' => t('Ordering material'),
    'unavailable-text' => t('Material cannot be orderd'),
    'invalid-pickup-branch-text' => t('Your pickup branch does not accept orders'),
    'success-text' => t('Material ordered'),
    'success-message' => t('Material ordered, your library will notify you when it is ready for pickup.'),
    'ids' => implode(',', $ids),
    'login-url' => ding_react_login_url(),
    'ill-check-url' => url('ding_ill/openholdingstatus', ['absolute' => TRUE]),
    'pickup-branch' => $preferred_branch,
    'expires' => $expiry->format('Y-m-d'),
  ];

  // Apparently `#attached` doesn't quite work here. But we have some
  // adjustments for the button.
  drupal_add_css(drupal_get_path('module', 'ding_ill') . '/ding_ill.css');

  $build[] = ding_react_app('order-material', $data);

  return $build;
}

/**
 * Implements hook_module_implements_alter().
 *
 * Ensure ding_ill's implmentation of opensearch_pre_execute runs after the
 * providers.
 */
function ding_ill_module_implements_alter(&$implementations, $hook) {
  if ($hook != 'opensearch_pre_execute') {
    return;
  }
  $ding_ill_implementation = $implementations['ding_ill'];
  unset($implementations['ding_ill']);
  $implementations['ding_ill'] = $ding_ill_implementation;
}

/**
 * Implements hook_opensearch_pre_execute().
 */
function ding_ill_opensearch_pre_execute($request) {
  if ($request instanceof TingClientSearchRequest) {
    // Do not filter for local holdings. The purpose of the interlibrary loans
    // module is to provide access to materials outside of the current library
    // organisation.
    $request->setFilterLocalHoldings(FALSE);
    // Exclude specific online types from the bibliotekskatalog source which
    // behave oddly. These are included when the local filter is removed.
    $request->setQuery(
      $request->getQuery() . ' not (term.acsource=bibliotekskatalog and (term.type="lydbog (net)" or term.type=ebog))'
    );
  }
}

/**
 * Implements hook_preprocess_field().
 */
function ding_ill_preprocess_field(&$variables) {
  if ($variables['element']['#field_name'] == 'ting_entities') {
    // Loop through the types. $variables['items'][0] must be a non-empty array,
    // empty collection doesn't make sense (and if we should encounter one, a
    // notice about it being an non-array is the least of our worries). But
    // first off, bail out if the first material isn't fiction, as we'll only
    // work on fiction materials.
    $firstType = element_children($variables['items'][0])[0];
    $firstPid = element_children($variables['items'][0][$firstType])[0];
    /* @var \TingEntity $ting_entity */
    $ting_entity = $variables['items'][0][$firstType][$firstPid]['#object'];
    if (!$ting_entity->getTingObject()->isFiction()) {
      return;
    }
    $view_mode = $variables['items'][0][$firstType][$firstPid]['#view_mode'];

    foreach (element_children($variables['items'][0]) as $type) {
      $materials = [];
      $rendered_materials = [];
      // In each material type group, group the materials again according to
      // title.
      foreach (element_children($variables['items'][0][$type]) as $pid) {
        // Collect the objects grouped by title.
        $object = $variables['items'][0][$type][$pid]['#object'];
        $materials[$object->title][$pid] = $object;
      }

      foreach ($materials as $items) {
        $pids = array_keys($items);
        foreach ($items as $pid => $object) {
          // Add the ids of related materials to materials.
          $object->ding_ill_ids = (array_search($pid, $pids) === 0) ? $pids : [ $pid ];

          if (!isset($rendered_materials[$object->title])) {
            // Using two buckets in order to order local materials before ill
            // materials.
            $rendered_materials[$object->title] = [
              'local' => [],
              'ill' => [],
            ];
          }

          // Rerender the object. This is not optimal for performance, but the
          // material has already been rendered with a button that only orders
          // the specific material. There's no hooks between
          // TingCollection::getEntities() constructing the list and
          // ting_field_formatter_view rendering the materials, so we'll have to
          // do it this way. If this is to be ported into Ding core, the
          // internal caching of getEntities should be fixed.
          // First off we need to ensure that fields gets re-rendered.
          unset($object->_field_view_prepared);
          $key = _ding_ill_is_local($object) ? 'local' : 'ill';
          $rendered_materials[$object->title][$key][$object->getId()] = ting_object_view($object, $view_mode);
        }
      }

      // Wrap each material type title group with attached styling and behavior.
      $path = drupal_get_path('module', 'ding_ill');
      $rendered_materials = array_map(function ($rendered_material_group) use ($path) {
        return array_merge(
          [
            '#prefix' => '<div class="ding-ill--material-group js-ding-ill-material-group">',
            '#suffix' => '</div>',
            '#attached' => [
              'css' => [$path . '/ding_ill.css'],
              'js' => [$path . '/ding_ill.js'],
            ],
          ],
          $rendered_material_group['local'],
          $rendered_material_group['ill']
        );
      }, $rendered_materials);

      // Replace the types entities with re-rendered.
      $variables['items'][0][$type] = array_merge(
        // Keep non-children from existing items to preserve any #prefix etc.
        array_diff_key(
          $variables['items'][0][$type],
          array_flip(element_children($variables['items'][0][$type]))
        ),
        $rendered_materials
      );
    }
  }
}

/**
 * Implements hook_preprocess_ting_object().
 */
function ding_ill_preprocess_ting_object(&$variables) {
  /* @var \TingEntity $object */
  $object = $variables['elements']['#object'];
  if (isset($object->ding_ill_ids)) {
    $variables['classes_array'][] = 'js-ding-ill-material';
  }
}

/**
 * Implements hook_js_alter().
 */
function ding_ill_js_alter(&$javascript) {
  $javascript = ding_ill_replace_ddb_react($javascript);
}

/**
 * Implements hook_css_alter().
 */
function ding_ill_css_alter(&$css) {
  $css = ding_ill_replace_ddb_react($css);
}

/**
 * Replace ddb-react assets with custom version.
 *
 * @param array $files
 *   A map from file paths to options array as set by drupal_add_js() and
 *   drupal_add_css().
 *
 * @return array
 *   An updated map where file paths to default ddb-reacr library is replaced
 *   by a custom version.
 */
function ding_ill_replace_ddb_react(array $files) {
  $ddb_react_path = libraries_get_path('ddb-react');
  $ding_ill_ddb_react_path = drupal_get_path('module',
  'ding_ill') . '/libraries/ddb-react';

  $ddb_react_files = array_filter($files,
  function ($file) use ($ddb_react_path) {
    return strpos($file, $ddb_react_path) === 0;
  }, ARRAY_FILTER_USE_KEY);

  array_walk($ddb_react_files,
  function (array &$file) use ($ddb_react_path, $ding_ill_ddb_react_path) {
    $file['data'] = str_replace($ddb_react_path, $ding_ill_ddb_react_path,
    $file['data']);
  });

  return array_merge($files, $ddb_react_files);
}

/**
 * Ajax openholdingstatus callback.
 *
 * @param string $pids
 *   Comma-separated list of pids.
 */
function ding_ill_openholdingstatus(string $pids) {
  drupal_add_http_header('Access-Control-Allow-Origin', '*');
  drupal_page_is_cacheable(FALSE);
  $res = ['canBeOrdered' => FALSE];
  $debug = isset($_GET['debug']);
  if ($debug) {
    $res['debug'] = [];
  }
  $cache_key = 'ding_ill_holdings:' . $pids;

  $cache = cache_get($cache_key);
  if (isset($cache->expire) && $cache->expire > REQUEST_TIME) {
    if ($debug) {
      $cache->data['debug'] = 'Found in cache ' . $cache_key;
    }
    drupal_json_output($cache->data);
    return;
  }

  $pids = explode(',', $pids);

  if ($pids) {
    $authXml = <<<EOF
  <ns1:authentication>
    <ns1:userIdAut>%s</ns1:userIdAut>
    <ns1:passwordAut>%s</ns1:passwordAut>
    <ns1:groupIdAut>%s</ns1:groupIdAut>
  </ns1:authentication>
EOF;

    $authXml = sprintf(
      $authXml,
      variable_get('ding_ill_auth_name', ''),
      variable_get('ding_ill_auth_pass', ''),
      variable_get('ding_ill_auth_group', '')
    );
    $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns1="http://oss.dbc.dk/ns/openholdingstatus"><SOAP-ENV:Body>
<ns1:localisationsRequest>
%s
  <ns1:agencyId>DK-870970</ns1:agencyId>
%s
  <ns1:mergePids>false</ns1:mergePids>
  <ns1:outputType>json</ns1:outputType>
</ns1:localisationsRequest>
</SOAP-ENV:Body></SOAP-ENV:Envelope>
EOF;

    $xmlPids = implode("\n", array_map(function ($pid) {
      return sprintf('    <ns1:pid>%s</ns1:pid>', $pid);
    }, $pids));

    // Compile a list of libraries that has the material and under what pid (it
    // might not be the same as the one we asked on).
    $response = drupal_http_request(
      'https://openholdingstatus.addi.dk/3.1/',
      ['data' => sprintf($xml, $authXml, $xmlPids)]
    );
    $json = json_decode($response->data, TRUE);

    $agencyPids = [];
    // Parse BadgerFish response. Don't know if there'll ever be more that one
    // localisation, but loop through them all to be sure.
    if (isset($json['localisationsResponse']['localisations'])) {
      foreach ($json['localisationsResponse']['localisations'] as $localisation) {
        if (isset($localisation['agency'])) {
          foreach ($localisation['agency'] as $agency) {
            $agencyId = $agency['agencyId']['$'];
            $localisationPid = $agency['localisationPid']['$'];

            // If the agency id starts with 7, it's a public library, and we
            // assume that if one has the material, at least one public library
            // must have it for lending. This speeds things up immensely.
            if (strpos($agencyId, '7') === 0) {
              if ($debug) {
                $res['debug'][] = sprintf('Found public library %s', $agencyId);
              }

              $res['canBeOrdered'] = TRUE;
              break 2;
            }

            $agencyPids[] = [$agencyId, $localisationPid];
          }
        }
      }
    }

    $i = 0;
    // If we have a list of pids and agency ids, loop through until we find one
    // that's available for ill.
    if (!$res['canBeOrdered'] && $agencyPids) {
      $xml = <<<EOF
<?xml version="1.0"?>
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns1="http://oss.dbc.dk/ns/openholdingstatus"><SOAP-ENV:Body>
<ns1:holdingsRequest>
%s
  <ns1:lookupRecord>
    <ns1:responderId>%s</ns1:responderId>
    <ns1:pid>%s</ns1:pid>
  </ns1:lookupRecord>
  <ns1:outputType>json</ns1:outputType>
</ns1:holdingsRequest>
</SOAP-ENV:Body></SOAP-ENV:Envelope>
EOF;

      foreach ($agencyPids as $agency) {
        list($agencyId, $pid) = $agency;

        if ($debug) {
          $res['debug'][] = sprintf('trying %s %s', $agencyId, $pid);
        }

        $response = drupal_http_request(
          'https://openholdingstatus.addi.dk/3.1/',
          ['data' => sprintf($xml, $authXml, $agencyId, $pid)]
        );
        $json = json_decode($response->data, TRUE);

        if ($debug) {
          $res['debug'][] = $json;
        }

        if (isset($json['holdingsResponse']['responder'])) {
          foreach ($json['holdingsResponse']['responder'] as $responder) {
            if ($i++ > 2) {
              break 2;
            }

            if ($responder['willLend']['$'] === 'true') {
              $res['canBeOrdered'] = TRUE;
              break 2;
            }
          }
        }
      }
    }
  }

  if ($debug) {
    $res['debug'][] = 'Cached as ' . $cache_key;
  }

  cache_set($cache_key, $res, 'cache', REQUEST_TIME + 86400);

  drupal_json_output($res);
}

/**
 * Check if entity is a local material.
 *
 * @param object $entity
 *   The entity to check.
 *
 * @return bool
 *   Whether it's local.
 */
function _ding_ill_is_local($entity) {
  $is_local = &drupal_static(__FUNCTION__);
  if (!isset($is_local[$entity->getId()])) {
    $local = FALSE;

    if ($entity->is('online')) {
      // Online materials are always considered local.
      $local = TRUE;
    } else {
      // An item is considered local if it has holdings regardless of what the
      // item id indicates.
      $local_id = $entity->getLocalId();
      $holdings = ding_availability_holdings([$local_id]);
      $has_holdings = $holdings[$local_id]['total_count'] > 0 ? TRUE : FALSE;
      $local = $has_holdings;
    }

    $is_local[$entity->getId()] = $local;
  }

  return $is_local[$entity->getId()];
}
